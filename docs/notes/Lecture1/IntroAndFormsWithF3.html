<html>
<head>
<title>Lectures 1-2 slides/notes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
p {
	font-family: Arial, Helvetica, sans-serif;
	font-size: 16px;
	color: #000000;
}
code {  font-family: "Courier New", Courier, mono; font-size: 14px}
.style1 {color: #FF0000}
.style4 {color: #006600}
.style5 {
	font-family: Arial, Helvetica, sans-serif;
	font-style: italic;
}
.style7 {color: #0000FF}
.style8 {color: #000000}
.style9 {color: #FF00CC}
.style10 {color: #F0292C}
.RedText {
	color: #FF0000;
}
-->
</style>
</head>

<body bgcolor="#FFFFFF" text="#000000">


<h1>Server-side systems and database serving<br>
  1: introduction and forms</h1>

<h1><i><a href="http://ddm.ace.ed.ac.uk/lectures/DDM/DynamicWebDesign/">Dynamic Web Design</a></i></h1>
<h3>John Lee</h3>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<h2>Introduction</h2>

<p class=MsoNormal>Dynamic web sites are everywhere. Very few are static HTML
  pages. E-commerce systems are dynamic; catalogues, searches, registration/login
  systems, shopping baskets, message boards, surveys, systems with cookies, RSS
  feeds -- all these are dynamic. We need to understand how to create and control
  them for ourselves. </p>
<p class=MsoNormal>Dynamic web sites are all about change: change not just in
  the way information is displayed (which we can achieve in the browser with
  Javascript, Flash, etc.), but change in the information itself. Information
  may be dynamically substituted with other information, or dynamically created
  from some other resource. This can only be done at the source of the information:
  the web server. </p>
<p class=MsoNormal>So in this course, we begin by turning our focus away from
  the web user's browser for a while, to consider the role of the web <i>server</i><span
style='font-style:normal'> in an interaction, and how we can use this to
    provide for different kinds of functionality. In particular, we look at how
    information can be obtained from the user by means of <em>form-filling</em>,
    and we begin to look at how it can be processed once we've got it. </span></p>
<p class=MsoNormal><span
style='font-style:normal'>We develop
  this line of discussion by starting to look at the use of <em>databases</em> and
  how they can be integrated to provide dynamic information through web sites.
    These are the techniques and technologies used by most commercial web sites,
    and this course should equip you to understand how these are created, and
    develop sites of these kinds for yourself. </span>We will start by considering
    the simplest kinds of web technologies and then move on to look at a system
    called PHP, which we will use in this course as
    our choice from a range of possible technologies with similar capabilities.</p>
<p class=MsoNormal>As ever in the Design and Digital Media (or Digital Media Design) programme, we are not aiming to do more in
  the lectures than introduce these things: it is up to you to pursue further
  resources to find more information and move to a more advanced level.</p>
<h2>The role of the server</h2>

<p class=MsoNormal>When you look at a web page, what actually happens is that
your browser connects to a server, specified in the first part of the URL, and
sends the server a <i>request</i><span style='font-style:normal'>, which
includes the whole URL. The server provides (i.e. </span><i>serves</i><span
style='font-style:normal'>) a specific document, specified by the rest of the
URL. </span></p>
<p class=MsoNormal><span
style='font-style:normal'>The document (which is usually just a file full of
    some kind of data) is downloaded onto your machine, and the browser identifies
    its <em><strong>type</strong></em>, usually through information in a “header” sent by the server (see
    below), which normally relates  to the file extension, &quot;.html&quot; etc.
    (but the header often takes precedence if the file extension is different).
    If it's HTML, or plain text, or a few other things, the browser will attempt
    to display it using its own resources; or it may offer it as input to a plugin;
    otherwise it may launch a helper application or just save the file somewhere.
    (Usually browser “preferences” determine how various kinds of document are
    handled; see also <a href="http://en.wikipedia.org/wiki/Internet_media_type" target="_blank">http://en.wikipedia.org/wiki/Internet_media_type</a>.)</span></p>
<p class=MsoNormal><span
style='font-style:normal'>Sometimes,
    the document requested by the browser does not already exist on the server
    machine, at least not in the required form. In that case, the request may
    fail, but alternatively the server may have been given instructions to do
    some processing to create or modify the document before serving it. </span></p>
<p class=MsoNormal><span
style='font-style:normal'>The HyperText
      Transfer Protocol (HTTP), which web applications typically use to communicate,
      is how requests are expressed when the URL begins with &quot;http:&quot;, and
      it allows one to specify some aspects of how the server should behave. </span></p>
<h2>CGI</h2>

<p class=MsoNormal>The &quot;Common Gateway Interface&quot; is a standard
mechanism whereby the server can be made to execute some application on the
server machine, and provide any result from the application as data to be sent
back to the originator of the request. </p>
<p class=MsoNormal>The server will execute the application;
    it will also pass as a <i><strong>parameter</strong></i><span style='font-style:normal'> to the application any
  component of the URL that follows a &quot;<strong>?</strong>&quot; character. Thus, if you visit
  the Google search site (<a href="http://www.google.com/" target="_blank">http://www.google.com/</a>) and execute a search for </span><i>MSc
  Design Digital Media</i><span style='font-style:normal'>, you'll notice
  that the URL in the browser changes to something like the following (roughly, though  the details may differ at different times and places):</span></p>
<p><code>http://www.google.com/search?hl=en&amp;q=MSc+Design+Digital+Media&amp;btnG=Google+Search</code></p>


<p class=MsoNormal>In this URL, <i>search,</i> just before the &quot;<em>?</em>&quot;, <span style='font-style:normal'>
will be the name of some application on the Google server machine, and the string </span><em>hl=en&amp;q=MSc+Design+Digital+Media&amp;btnG=Google+Search</em> <span style='font-style:normal'>is
what's handed to it as a parameter. </span></p>
<p class=MsoNormal><span style='font-style:normal'>By convention, this parameter
    string (often called the &quot;<em>query
  string</em>&quot;) consists of a list
  of named parameters (in this case three: </span><i>h1, q, </i>and<i> btnG</i><span
style='font-style:normal'>) and their values, linked by &quot;=&quot;. The
  parameter-value pairs are separated by &quot;&amp;&quot;. Within parameter
  values, words are separated with the &quot;+&quot; character.</span></p>
<p class=MsoNormal><span
style='font-style:normal'>Spaces are not
  allowed: any such non-alphanumeric characters are represented by &quot;%&quot;
  and then their ASCII code as a two-digit hexadecimal number, so if spaces do
  appear they are encoded as &quot;%20&quot;. (Because the ASCII code for a space is 32 in decimal, 20 in hex. This arrangement is called </span><i>URL
  encoding</i><span style='font-style:normal'>, and has to be used in all URLs,
  though most browsers now will silently encode URLs before sending them if you just type
  them in directly.)</span></p>
<h2>The HTTP request methods</h2>
<p class=MsoNormal>When a request is sent to a server, a <i><strong>method</strong></i><span
style='font-style:normal'> is specified for handling any data associated with
    the request. Usually, this is either GET or POST. The former of these is
    notionally associated with getting information from the server, while the
    latter is associated with posting data to it; however these are often not
    very distinct. Either way, some facility is available for the server to obtain
    information from the browser, which may then be somehow processed (and then
    probably other information will be sent back as a response). </span></p>
<p class=MsoNormal><span
style='font-style:normal'>In the case of <em>forms</em>, the browser is in fact
    providing data to the server, but it can do this using either GET or POST
    methods -- the information is simply sent in different ways. We will normally
    use the POST method for form data, because it has some security advantages.</span></p>
<h2>Forms</h2>

<p class=MsoNormal>HTML forms are, at their simplest, just a quick and convenient
way of adding information to an HTTP request. For example, they can be used to
  construct a query string for a CGI URL. </p>
<p class=MsoNormal>Suppose we have an application
    on our server that saves people's names in a file, and the application is
  called <i>namesave.cgi</i><span
style='font-style:normal'>. If one executes it with a name as parameter, it
  will add the name to a file. We could have the user always type in a URL ending
  with</span><o:p></o:p></p>
<p class=MsoNormal style='text-indent:36.0pt; font-size: 14pt;'><span style='font-family:Courier'>.../namesave.cgi?name=John+Smith</span><o:p></o:p></p>

<p class=MsoNormal>(or whatever their name might be), but this is not at all
convenient. Usually the user would be put off by this, and it is more practical,
  as well as more attractive and simpler, to provide instead an
  HTML form as follows.</p>

<p><code>
&lt;html&gt;<br>
&lt;head&gt;<br>
&lt;title&gt;Simple example form&lt;/title&gt;<br>
&lt;/head&gt;<br>
&lt;body&gt;<br>
&lt;h1&gt;An example of a very simple form&lt;/h1&gt;<br>

&lt;p&gt;<br>

&lt;form method=&quot;GET&quot;
action=&quot;namesave.cgi&quot;&gt;<br>

Enter your name here:<span style="mso-spacerun: yes">&nbsp;
</span><br>

&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;<br>

&lt;input type=&quot;submit&quot;&gt;<br>

&lt;input type=&quot;reset&quot;&gt;<br>

&lt;/form&gt;<br>

&lt;/body&gt;<br>

&lt;/html&gt;<br>
</code><o:p></o:p>
<p class=MsoNormal>When this HTML is displayed, it looks as follows (<a href="http://ddm.caad.ed.ac.uk/lectures/DDM/Intro_Digital_Media/Lecture11/simpleform.html" target="_blank">or
  as at this link</a>):
  <o:p></o:p></p>

<p class=MsoNormal><!--[if gte vml 1]><o:wrapblock><v:shapetype id="_x0000_t75"
  coordsize="21600,21600" o:spt="75" o:preferrelative="t" path="m@4@5l@4@11@9@11@9@5xe"
  filled="f" stroked="f">
  <v:stroke joinstyle="miter"/>
  <v:formulas>
   <v:f eqn="if lineDrawn pixelLineWidth 0"/>
   <v:f eqn="sum @0 1 0"/>
   <v:f eqn="sum 0 0 @1"/>
   <v:f eqn="prod @2 1 2"/>
   <v:f eqn="prod @3 21600 pixelWidth"/>
   <v:f eqn="prod @3 21600 pixelHeight"/>
   <v:f eqn="sum @0 0 1"/>
   <v:f eqn="prod @6 1 2"/>
   <v:f eqn="prod @7 21600 pixelWidth"/>
   <v:f eqn="sum @8 21600 0"/>
   <v:f eqn="prod @7 21600 pixelHeight"/>
   <v:f eqn="sum @10 21600 0"/>
  </v:formulas>
  <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
  <o:lock v:ext="edit" aspectratio="t"/>
 </v:shapetype><v:shape id="_x0000_s1026" type="#_x0000_t75" style='position:absolute;
  margin-left:0;margin-top:0;width:395pt;height:129pt;z-index:1' o:allowincell="f">
  <v:imagedata src="Lecture1notes_files/image001.png" o:title=""/>
  <w:wrap type="topAndBottom"/>
 </v:shape><![endif]--><![if !vml]>
  <img
 src="Lecture1notes_files/image002.jpg" width=395 height=129 border="0" v:shapes="_x0000_s1026">
  <![endif]><!--[if gte vml 1]></o:wrapblock><![endif]--><br style='mso-ignore:vglayout' clear=all>
</p>

<p class=MsoNormal>And when the Submit button is clicked, the URL changes to
the one shown above, i.e. it ends in <em>namesave.cgi</em> (and what comes before
that depends on the URL of the form itself, because in the HTML of the form
<em>action</em> attribute we have used a <em>relative link -- </em>relative and
absolute links work in forms just the same way as anywhere else). <span class="RedText">[NB, the application
in this example is now a dummy, so you'll get a &quot;permission
denied&quot; message when you try to execute it, but you can still see what happens
to the URL.]</span></p>
<!--<p class=MsoNormal>(<a href="http://ddm.caad.ed.ac.uk/lectures/DDM/Intro_Digital_Media/Lecture11/listnames.cgi" target="_blank">Access
  this link to see where the input went ...</a>) </p> -->
<p class=MsoNormal>This
  principle can be extended, in that there are a considerable range of types
  of input available (lists, buttons, checkboxes, etc.), and clearly the URL
  produced can become very complicated, but the mechanism remains the same.</p>
<p class=MsoNormal>Editors such as Dreamweaver make the creation of forms very
simple. The trickier part comes when you want to do something with the data
they create. The basic mechanism is fairly simple: the &quot;form&quot; tag
specifies through its &quot;action&quot; attribute a CGI application that will
be used by the server to process the form data, and the method (GET
or POST) will be as specified by the &quot;method&quot; attribute:</p>
<p class=MsoNormal><code>
&lt;form method=&quot;GET&quot; action=&quot;namesave.cgi&quot;&gt;</code></p>
<p class=MsoNormal> All you need
  to do, then, is decide what application to use and create a program that handles
  the data appropriately.<o:p></o:p></p>
<p class=MsoNormal>The most obvious difference between GET and POST, in
practice, is that whereas the GET method sends parameters via the URL as
described above, POST causes the information to be sent in a different way,
which is not visible on the URL.<span style="mso-spacerun: yes">&nbsp;
</span>We have chosen to use GET here for clarity, but obviously POST may have
 advantages in many situations. The application that processes the data
will also have to decode it differently depending on which of these methods is
used, and decoding POST information is more complicated. (With PHP, as we'll
see below, we normally use POST for form data, but we will not need to know the details of how
PHP decodes it.)</p>
<p class=MsoNormal>Remember that the URL query string can be used even wihout
  forms, to provide information for an application. This will
  continue to be important for us.</p>
<p class=MsoNormal>We are concerned here only with the &quot;back-end&quot; processing of form data, but the appearance and behaviour of the form for the user is of course also very important. HTML5 provides many useful features in this respect and is now the best choice for form development (see the Forms chapter in the excellent <em>Dive into HTML5</em> for explanation and examples — <a href="http://diveintohtml5.info/forms.html">http://diveintohtml5.info/forms.html</a>).</p>
<h2>The processing script</h2>

<p class=MsoNormal>The application program you create to handle form data could
  be almost anything that can be run on the server machine. You could write it
  in C, Java, Prolog, Applescript, Visual Basic, FileMaker Pro or various other
things that might be available. The key factor is that the server runs the application
in an <em>environment</em> where it is provided with the values for various variables
as part of the CGI interface, which includes the query string, along with things
like the user's IP number, the kind of browser they're using, etc.</p>
<p class=MsoNormal>Often, however, form data is processed by some system that
  is more integrated with the task of producing HTML pages from other data. Such
  systems are PHP, ASP, JSP, Coldfusion, and others. These can all be used for
  a range of CGI-related purposes. We are going to use PHP, which is just one
  example. You are welcome to look at and compare the others if you want. (PHP
  can be used on our own server -- details follow. ASP is normally available
only on Windows-based servers, but the others are supported on various platforms.) </p>
<p class=MsoNormal>What happens with all of these systems is that you write <em>templates</em>,
  which are HTML pages that have instructions of some kind embedded in them.
  The server processes the template by removing the instructions and replacing
  them with more HTML that the instructions tell it how to create, often using
  data or other resources that may be different at different times. Hence the
  final page that the user sees is created <em>dynamically</em> just at the moment
  it is asked for, and so it can be updated in many ways that would be impossible
  with a static page.</p>
<h2>PHP</h2>
<p>We have chosen PHP mainly because it is free, open source
  software and very widely used. It is also extremely powerful. Its development
  history is well described at <a href="http://uk.php.net/manual/en/history.php">http://uk.php.net/manual/en/history.php</a>.
  It has a comprehensive manual, as well as tutorials and other material, on
  its own web site at <a href="http://uk.php.net/docs.php" target="_blank">http://uk.php.net/docs.php</a>.
  It is also well integrated with Dreamweaver for editing and design purposes.</p>
<p>You can install PHP on your own computer (e.g. laptop), along with the MySQL
  database and the Apache web server, in the form of a neatly packaged setup
  called (if you are using a Macintosh) MAMP (<a href="www.mamp.info/">www.mamp.info/</a>).
  This stands for &quot;Macintosh,
  Apache, MySQL, PHP&quot;, and derives from the original LAMP, which is for
  the Linux operating system. There is also WAMP or WampServer for Windows machines.
  We do not undertake to support students in running any setup on their own
  machines: if you wish to try it, this is up to you. We provide access to all
  the components on the studio systems, as described <a href="additional14.html" target="_blank">at this link</a>.</p>
<p>PHP defines a language written between tags that are placed within HTML pages (or in files that have no HTML, which function simply as PHP scripts).
  The tags open with &quot;<strong><em>&lt;?php</em></strong>&quot;, and close with &quot;<em><strong>?&gt;</strong></em>&quot;;
  they are embedded in ordinary HTML pages that are placed on a machine with
  a special PHP web server (which is often an extension of the server that serves
  plain HTML web pages). These pages are sometimes known as <i>templates</i>.
  When they are served by the server, <em>all the PHP code, with its tags, disappears</em> and
  is replaced by pieces of HTML that depend on what the PHP statements specified.
  The resulting page is therefore interpretable by any normal browser. If you
  look at the HTML source of any PHP page as it arrives at your browser, you
  will find nothing other than ordinary HTML, CSS etc. -- no trace of PHP code. With this kind of system,
  the pages can be designed exactly as usual, but with these PHP tags as placeholders
  for material that will be provided dynamically when the page is viewed in the
  user's browser.</p>
<p>So there is no PHP user interface: you design your page templates using Dreamweaver,
  or any other text editor, and you include PHP script elements into the HTML.
  Dreamweaver and some other editors will have functionality that helps you to
  do this, but you don't have to use it. Your template contains
  nothing but text. Then you place the templates onto the PHP-enabled web server and access
  them via a web browser, like
  any other
  web pages.</p>
<p>There
  are many  books on PHP, and even more material on the web — a good introduction
  can be found, as usual, <a href="http://www.w3schools.com/php/">at w3schools.com</a>, And, of course, there is much excellent material on Lynda.com.</p>
<p>There are plenty of things you can do with PHP without needing to use a database.
  Here's a simple example of a PHP page. I will refer to the parts <strong>within
the PHP tags</strong> as <em>script</em> elements, or simply <em>the PHP script</em>. </p>
<p><code>&lt;HTML&gt;<br>
  &lt;HEAD&gt;<br>
  &lt;TITLE&gt;PHP Example&lt;/TITLE&gt;<br>
  &lt;/HEAD&gt;<br>
  /&lt;BODY&gt;<br>
  &lt;H2&gt;Today's date is<br>
  </code><code>&lt;?php<br>
    echo date(&quot;d/m/Y&quot;);<br>
  </code><code>?&gt;<br>
  &lt;/H2&gt;<br>
  &lt;/BODY&gt;<br>
  &lt;/HTML&gt;</code></p>
<p>This is clearly HTML with just the embedded PHP tags. Within the scope of
  these tags, everything is taken to be PHP code that should be evaluated. In
  this case, the result of the evaluation (which is today's date) is simply inserted
  into the HTML page and handed to the user's browser. What appears on the browser
  (at the time of editing these notes) is simply:</p>
<h2>Today's date is 11/01/2019</h2>
<p>(Try <a href="http://playground.eca.ed.ac.uk/~jlee/test/date.php" target="_blank">http://playground.eca.ed.ac.uk/~jlee/test/date.php</a>.
  See if you can guess how to make it put the day before the month!) </p>
<p>The processing of this page is illustrated in the following diagram (click
  for larger version).</p>
<p><a href="PHP-process.png" target="_blank"><img src="PHP-process.png" width="547" height="427" alt="PHP processing diagram"></a></p>
<p class="RedText"><em>Always remember that the PHP script is only processed if the page
  is <strong>requested from the server</strong>, i.e. if you use a browser and <strong>a URL that begins with http:// </strong>...
  If you access the template file <strong>directly</strong> with a browser (in which
  case your URL will begin <strong>file://</strong>) then the script will <strong>not</strong> be processed and so you will <strong>not</strong> see the result you expect.</em></p>
<p>This is the basic idea behind PHP, which means &quot;PHP: Hypertext Preprocessor&quot;
  —  it pre-processes your web pages in various ways before they are
  served to the user. PHP has a very wide range of capabilities and can be
  used for a great many things. Here we'll talk mainly about forms and databases,
  but there is also support for email, searching, http connectivity, security
  and encryption, graphing and charting, and more advanced scripting. See the
  many books available (or the PHP web site, which has very good documentation)
  for details. </p>
<h2>The Fat-Free Framework (F3) </h2>
<p>In this course, we are going to use a <em>framework</em>, which is essentially a set of scripts written in PHP that create a system in which we can build web applications much more simply and securely than by using straight or &quot;vanilla&quot; PHP by itself. There are many PHP frameworks — dozens, at least — but most of them are very complicated, may cost money, require installation procedures that we are not able to use on our server, and take a lot of effort to learn. The Fat Free Framework (commonly known as &quot;F3&quot;) is less well-known than some of the others (e.g. Laravel), but is much, much simpler. It still does everything we need for this course, and a lot more besides, but it's relatively easy to learn and use, is free and open-source, and does not need to be installed into the server itself. Learning F3 is a good preparation for learning more complex frameworks, if you need to later, because it is based on the same principles as many of them.</p>
<h3>Routes</h3>
<p>A key concept in F3, as in many frameworks, is the <em>route</em>.   A URL as described above normally identifies a file, which may contain a script that will be executed, but in F3 a URL usually identifies a route. A              route is actually interpreted by a PHP function that you define within a PHP file, usually <em>index.php</em>. This function provides a rule for interpreting the route. Normally, any URL that ends in a trailing slash (&quot;/&quot;) is interpreted as ending at a folder (in these notes we will call a folder a <em>directory</em>, in keeping with UNIX terminology) and implicitly identifying the file <em>index.suffix</em> in that directory (where <em>suffix</em> may be html, jpg, php, etc.). If the file <em>index.php</em> exists, it will be executed on the PHP interpreter; <em>index.html</em> would simply be served as a webpage, etc. There should only ever be one<em> index</em> file, so the URL with the trailing slash has an identical result to one that has the index file on the end. </p>
<p>But in F3, things are different. The index.php file is taken as a file that defines various setup parameters and routes. The URL that ends in a trailing slash is taken to identify a route defined in the index.php file. If &quot;index.php&quot; is added to the end of the URL, it will  fail, unless a route for the resulting URL is explicitly defined. Normal URL behaviour seems to be turned on its head.</p>
<p>This is possible because, in the directory identified by the URL, there is a file called &quot;.htaccess&quot; (but because it starts with &quot;.&quot; it is usually hidden by default in file views), in which a <em>redirection</em> is defined. Redirection is a general facility offered by web servers, whereby rules can be defined that cause a URL to be redirected to somewhere else, by being rewritten as a different URL. In the F3 case, any URL that points into this directory is processed as a route, according to rules that are defined in index.php. This is achieved through the <em>.htaccess</em> file containing the following:</p>
<p><code>RewriteEngine On<br>
  RewriteCond %{REQUEST_FILENAME} !-f<br>
  RewriteCond %{REQUEST_FILENAME} !-d<br>
  RewriteCond %{REQUEST_FILENAME} !-l<br>
  RewriteRule .* index.php [L,QSA]</code></p>
<p>Roughly speaking, this means: (line 1) the RewriteEngine is activated; (lines 2-4) if a URL is requested from this directory that looks like a filename but isn't  a file, directory or link, it is (line 5) passed to the RewriteRule that says it is rewritten to <em>index.php</em> (in the same directory as the <em>.htaccess</em> file). </p>
<p>This .htaccess file has to be in the home directory of the F3 application, and each F3 application will require its own .htaccess file (though usually they are all identical to the above).</p>
<p><span class="RedText"><strong>Important note:</strong></span> there is a wrinkle here, in that the rewrite mechanism will not work in this simple way on our Playground server, or in other situations where other types of rewriting are happening. On the Playground server, our URLs  typically include a component that starts with &quot;~&quot;, followed by a username (e.g., in my case, &quot;~jlee&quot;), which identifies with the &quot;html&quot; directory (web root) of a particular user. In this kind of context, the resolving of the &quot;~&quot; seems to confuse the resolving of the rewrite. To get around this, the .htaccess file needs to have another line that specifies the application home directory, so in full it should be (for my directory on Playground):</p>
<p><code>RewriteEngine On<br>
RewriteCond %{REQUEST_FILENAME} !-f<br>
RewriteCond %{REQUEST_FILENAME} !-d<br>
RewriteCond %{REQUEST_FILENAME} !-l<br>
RewriteRule .* index.php [L,QSA]<br>
RewriteBase /~jlee/fatfree/FFF-simpleExample/</code></p>
<p>For you, this final line will be different, depending on the name of the directory you are using. If your student id is <em>s1900000</em>, then the directory will be <em>/~s1900000/fatree/FFF-simpleExample</em> if you have called your directory &quot;FFF-simpleExample&quot; and put it inside a directory called &quot;fatfree&quot; in your html directory.</p>
<p>So in the FFF-SimpleExample example discussed in the introductory Viewtorial for this course, the home directory of the F3 application is <em>.../FFF-SimpleExample/</em> (where &quot;...&quot; is the file system path to the directory, e.g., on my laptop, /Users/jlee/Sites/fatfree/FFF-SimpleExample/). In this directory there is a .htaccess file as above. When I visit the URL <em>http://localhost/fatfree/FFF-SimpleExample/</em> the server will go to index.php, but then it will look for a rule defining the directory as a route, bearing in mind that by default my browser will be sending an HTTP request using the method GET. This rule appears as:</p>
<p><code>$f3-&gt;route('GET /',<br>
function ($f3) {<br>
$f3-&gt;set('html_title','Simple Example Home');<br>
$f3-&gt;set('content','simpleform.html');<br>
echo Template::instance()-&gt;render('layout.html');<br>
}<br>
);</code></p>
<p>This says that the F3  method <em>route</em> (a method of the F3 object represented by <em>$f3</em>)<em> </em>is called with two arguments. Each use of this method constitutes a rule that defines a route. The first argument is a string, 'GET /'. This means the route matches an HTTP GET request for &quot;/&quot;, which  here represents the root directory of the application, i.e. the URL we are discussing. The second argument is a function definition, an anonymous function that sets two F3 variables and then calls the <em>render</em> method of the <em>Template</em> object to render a template, <em>layout.html</em>.</p>
<p>In general, a route will need a first argument that specifies an HTTP method and a URL element, and a second that specifies or defines a function to run. In  FFF-SimpleExample, there is another route rule, for example, that looks like this:</p>
<p><code>$f3-&gt;route('GET /simpleform',<br>
function($f3) {<br>
$f3-&gt;set('html_title','Simple Input Form');<br>
$f3-&gt;set('content','simpleform.html');<br>
	echo template::instance()-&gt;render('layout ().html');<br>
}<br>
);</code></p>
<p>which says that the URL where &quot;/simpleform&quot; appears at the end of the root URL – i.e. <em>http://localhost/fatfree/FFF-SimpleExample/simpleform</em> –  will produce exacly the same effect as the root URL – it will display the Simple Form page – but with a different title on the page. (In both cases, the <em>layout,html</em> template is rendered, with its <em>content</em> variable being set to &quot;simpleform.html&quot;, but its <em>html_title</em> variable being different.)</p>
<p>If the simpleform URL is requested with the HTTP method POST (which in this case occurs when it is used as the action of the HTML form), we get a completely different result, because the route rule for 'POST /simpleform' is quite different.</p>
<p>Routes are absolutely fundamental to the use of F3, and also support various other feaatures such as the use of parameters on URLs. These are shown in the F3 documentstion, and some of them used in the course examples.</p>
<h3>Templates</h3>
<p>Another concept fundamental to F3, and to most other frameworks, is the idea of a template. A template is usually an HTML page that contains elements which will be replaced when the page is <em>rendered</em> (turned into normal HTML for display by the browser). Typically, they will be replaced by values drawn from a database, or computed in some way. In F3, these elements are recognised by being enclosed in curly double braces, e.g.</p>
<p><code>{{ @html_title }}</code></p>
<p>–  if we find this embedded in normal HTML, it means that when the template is rendered, this will be removed completely and replaced, in this cse, by the value of the F3 variable <em>html_title</em> (any white space between the double braces will be removed as well). The &quot;@&quot; symbol just directs the interpreter to look for an F3 variable. Other things can be done as well – see the F3 documentation for details. </p>
<p>Crucially, the template system supports contructions such as loops. Suppose we have an F3 variable whose value is an array (it could be an array of strings, or numbers, or an associative array). Then we can loop through the array and produce HTML, for example a table, that includes all of the values in it:</p>
<p><code>&lt;table&gt;<br>
&lt;tr&gt;<br>
&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Colour&lt;/th&gt;<br>
&lt;/tr&gt;<br>
&lt;repeat group=&quot;{{ @dbData }}&quot; value=&quot;{{ @record }}&quot;&gt;<br>
&lt;tr&gt;<br>
&lt;td&gt;{{ trim(@record.name) }}&lt;/td&gt;<br>
&lt;td&gt;{{ trim(@record.colour) }}&lt;/td&gt;<br>
&lt;/tr&gt;<br>
&lt;/repeat&gt;<br>
&lt;/table&gt;</code></p>
<p>Here, between the <em>&lt;repeat&gt;</em> tags, we have a table row with two cells. Attributes of the opening tag are <em>group</em> and <em>value</em>. The group is set to an F3 variable that contains an array; the value is used to create an F3 variable (record) that will hold one of the array members each time round the loop. The array contains associative pairs, each with keys name and  colour. The expression trim(@record.name) simply takes the name element in the current record and trims any leading or trailing white space from it. So this repeat loops through the array, and for each element in it produces a row in the HTML table that puts the name and the colour into separate cells, as you can see in SimpleExample by using the <em>dataView</em> route (URL ending in <em>FFF-SimpleExample/dataView</em>) -- this HTML is from the template <em>dataView.htm</em>l.</p>
<p> We can take advantage of any features of HTML that we like, so for instance if we had a URL in the database then, rather than just printing it out,  it's easy to make it into a clickable link. We could also of course style this page by simply adding any required  id or class attributes and some CSS styles or a link to a  stylesheet. Since the data we are displaying on the page we are creating here is tabular
  data, it makes sense to use a table to present it, but instead we could generate a whole series of DIVs etc. if we wanted. Then we would certainly want to use CSS for formatting – we
  could even, if we wanted, write PHP code to generate or adapt CSS dynamically,
so that things would be formatted differently in different circumstances.</p>
<h3>Forms in F3</h3>
<p>A key item in SimpleExample is the simple form that allows the user to enter their name and choose a colour. The HTML for this is very simple:</p>
<p><code>&lt;p&gt;This is a simple form&lt;/p&gt;<br>
  &lt;form id=&quot;form1&quot; name=&quot;form1&quot; method=&quot;post&quot; action=&quot;{{ @BASE }}/simpleform&quot;&gt;<br>
Please enter your name: <br>
&lt;input name=&quot;name&quot; type=&quot;text&quot; placeholder=&quot;Enter name&quot; id=&quot;name&quot; size=&quot;50&quot; /&gt;<br>
<br>&lt;p&gt;Choose a colour: <br>
  &lt;select name=&quot;colour&quot; id=&quot;colour&quot;&gt;<br>
  &lt;option value=&quot;blue&quot;&gt;Blue&lt;/option&gt;<br>
  &lt;option value=&quot;red&quot; selected=&quot;selected&quot;&gt;Red&lt;/option&gt;<br>
  &lt;option value=&quot;green&quot;&gt;Green&lt;/option&gt;<br>
  &lt;/select&gt;<br>
  &lt;/p&gt;<br>
  &lt;p&gt;<br>
  &lt;input type=&quot;submit&quot; name=&quot;Submit&quot; value=&quot;Submit&quot; /&gt;<br>
  &lt;/p&gt;<br>
	&lt;/form&gt;</code></p>
<p>The first main point to note is the <em>action</em> attribute of the opening <em>&lt;form&gt;</em> tag: it is a URL, formed by adding &quot;/simpleform&quot; to the URL of the F3 SimpleExample directory, which is available through the F3 variable <em>@BASE</em>. Also, the <em>method</em> attribute is set to &quot;post&quot; (which isn't case sensitive). This means that when we click the Submit button, the form makes a POST request to the <em>simpleform</em> route. Hence, F3 looks in <em>index.php</em> for a rule that begins with 'POST /simpleform', and it finds</p>
<p><code>$f3-&gt;route('POST /simpleform',<br>
function($f3) {<br>
<span class="style7">$formdata = array()</span>;			// array to pass on the entered data in<br>
<span class="style7">$formdata[&quot;name&quot;]</span> = <span class="RedText">$f3-&gt;get('POST.name')</span>;			// whatever was called &quot;name&quot; on the form<br>
<span class="style7">$formdata[&quot;colour&quot;]</span> = <span class="RedText">$f3-&gt;get('POST.colour')</span>;		// whatever was called &quot;colour&quot; on the form<br>
<br>
$controller = new SimpleController;<br>
<span class="style4">$controller-&gt;putIntoDatabase($formdata)</span>;<br>
<br>
<span class="style9">$f3-&gt;set('formData',$formdata)</span>;		// set info in F3 variable for access in response template<br>
<br>
$f3-&gt;set('html_title','Simple Example Response');<br>
$f3-&gt;set('content','response.html');<br>
echo template::instance()-&gt;render('layout.html');<br>
}<br>
	);</pre></code></p>
<p>This looks slightly complicated, but basically it  <span class="RedText">extracts the data entered on the form</span>. This comes to F3 as members of the <em>POST</em> object: one for each HTML <em>input </em>or <em>select</em> on the form. The form defined an input called <em>name</em> and a select called <em>colour</em>: hence, the POST object has members <em>POST.name</em> and <em>POST.colour</em>. The code takes these and packs them into <span class="style7">a two-element associative array called <em>$formdata</em></span>, which <span class="style4">it then hands to the controller function that puts the elements into the database</span>. If the items on the form, the keys in the array and the fields in the database all consistently use the same names, the scheme is very clear and easy to maintain, modify, etc. Finally, <span class="style9">the <em>$formdata</em> array is also put into the F3 variable <em>formdata</em></span>, <span class="style9">which  the <em>response.html</em> template will use to show the user that it got the correct values:</span></p>
<p><code>&lt;h1&gt;Thanks for your data, <span class="style9">{{ @formData.name }}</span> ...&lt;/h1&gt;<br>
  &lt;p&gt; Your colour was <span class="style9">{{ @formData.colour }}</span> &lt;/p&gt;<br>
  &lt;hr /&gt;<br>
&lt;a href=&quot;{{ @BASE }}/dataView&quot;&gt;Show all data&lt;/a&gt;</code></p>
<h3>The GET object</h3>
<p>Variables that are provided to a template in a query string as part
  of the URL (or from a form that uses the HTTP GET method) are also made very
  simply and directly available, similarly to POST variables, as members of a
  standard F3 object called <em>GET</em>. Thus if we have a route called as <em>.../route?var=val</em> then
  in the route rule itself we can access <em>GET.var </em>(using $f3-&gt;get()) and discover
  that its value is <em>val</em>. </p>
<h3>The PARAMS object</h3>
<p>In F3 applications, the GET option is not used as much as when working with vanilla PHP, because F3 defines an alternative means of getting parameters via the URL. You can add a parameter as an extension to the URL, by simply adding &quot;/&quot; followed by the parameter value. The route rule can then be written to allow this to be accessed as follows:</p>
<p><code>$f3-&gt;route('GET /example/<span class="RedText">@var</span>',<br>
function($f3) {<br>
echo &quot;The parameter value you gave was: &quot; . <span class="RedText">$f3-&gt;get('PARAMS.var')</span>;<br>
}<br>
}</code></p>
<p>If you now browse to the URL <em>&quot;.../example/fish&quot;</em>, then the application will respond &quot;The parameter value you gave was: fish&quot;. This is something we'll see used in a few examples during the course. Note that this is a separate route rule from one that you might have for <code>'GET /example/</code>' (with no parameter) – you will need to define that as a separate rule if you want to allow a URL with no added parameters, otherwise an error will result.</p>
</body>
</html>